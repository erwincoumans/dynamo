This is Info file DLdoc.info, produced by Makeinfo version 1.68 from
the input file DLdoc.texi.


File: DLdoc.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

* Menu:

* Copying::	    GNU Library Public License says how you can copy
                    and share Dynamo.
* Introduction::             Introduction to this document.
* Dynamics overview::        Explains what (inverse) dynamics entails.
* General notes::            Some general remarks about the library.
* Installation::             Explains what has to be done in order to be
                             able to use the Dynamo library.
* Example::                  A simple example
* General classes::          Presents the API of the general classes
* Forward dynamics classes:: Presents the forward dynamics classes and
                             explains their API.
* Inverse dynamics classes:: Presents the Inverse dynamics classes and
                             explains their API.
* Miscellaneous classes::    Curves, Surfaces and other extra classes.


File: DLdoc.info,  Node: Copying,  Next: Introduction,  Prev: Top,  Up: Top

GNU LIBRARY GENERAL PUBLIC LICENSE
**********************************

                         Version 2, June 1991

     Copyright (C) 1991 Free Software Foundation, Inc.
     59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.
     
     [This is the first released version of the library GPL.  It is
      numbered 2 because it goes with version 2 of the ordinary GPL.]

Preamble
========

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public Licenses
are intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.

This license, the Library General Public License, applies to some
specially designated Free Software Foundation software, and to any
other libraries whose authors decide to use it.  You can use it for
your libraries, too.

When we speak of free software, we are referring to freedom, not price.
Our General Public Licenses are designed to make sure that you have
the freedom to distribute copies of free software (and charge for this
service if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs; and that you know you can do these things.

To protect your rights, we need to make restrictions that forbid anyone
to deny you these rights or to ask you to surrender the rights.  These
restrictions translate to certain responsibilities for you if you
distribute copies of the library, or if you modify it.

For example, if you distribute copies of the library, whether gratis or
for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link a program with the library, you must provide
complete object files to the recipients so that they can relink them
with the library, after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

Our method of protecting your rights has two steps: (1) copyright the
library, and (2) offer you this license which gives you legal
permission to copy, distribute and/or modify the library.

Also, for each distributor's protection, we want to make certain that
everyone understands that there is no warranty for this free library.
If the library is modified by someone else and passed on, we want its
recipients to know that what they have is not the original version, so
that any problems introduced by others will not reflect on the original
authors' reputations.

Finally, any free program is threatened constantly by software patents.
We wish to avoid the danger that companies distributing free software
will individually obtain patent licenses, thus in effect transforming
the program into proprietary software.  To prevent this, we have made
it clear that any patent must be licensed for everyone's free use or
not licensed at all.

Most GNU software, including some libraries, is covered by the ordinary
GNU General Public License, which was designed for utility programs.
This license, the GNU Library General Public License, applies to certain
designated libraries.  This license is quite different from the ordinary
one; be sure to read it in full, and don't assume that anything in it is
the same as in the ordinary license.

The reason we have a separate public license for some libraries is that
they blur the distinction we usually make between modifying or adding
to a program and simply using it.  Linking a program with a library,
without changing the library, is in some sense simply using the
library, and is analogous to running a utility program or application
program.  However, in a textual and legal sense, the linked executable
is a combined work, a derivative of the original library, and the
ordinary General Public License treats it as such.

Because of this blurred distinction, using the ordinary General Public
License for libraries did not effectively promote software sharing,
because most developers did not use the libraries.  We concluded that
weaker conditions might promote sharing better.

However, unrestricted linking of non-free programs would deprive the
users of those programs of all benefit from the free status of the
libraries themselves.  This Library General Public License is intended
to permit developers of non-free programs to use free libraries, while
preserving your freedom as a user of such programs to change the free
libraries that are incorporated in them.  (We have not seen how to
achieve this as regards changes in header files, but we have achieved
it as regards changes in the actual functions of the Library.)  The
hope is that this will lead to faster development of free libraries.

The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, while the latter only
works together with the library.

Note that it is possible for a library to be covered by the ordinary
General Public License rather than by this special one.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library which
     contains a notice placed by the copyright holder or other
     authorized party saying it may be distributed under the terms of
     this Library General Public License (also called "this License").
     Each licensee is addressed as "you".

     A "library" means a collection of software functions and/or data
     prepared so as to be conveniently linked with application programs
     (which use some of those functions and data) to form executables.

     The "Library", below, refers to any such software library or work
     which has been distributed under these terms.  A "work based on the
     Library" means either the Library or any derivative work under
     copyright law: that is to say, a work containing the Library or a
     portion of it, either verbatim or with modifications and/or
     translated straightforwardly into another language.  (Hereinafter,
     translation is included without limitation in the term
     "modification".)

     "Source code" for a work means the preferred form of the work for
     making modifications to it.  For a library, complete source code
     means all the source code for all modules it contains, plus any
     associated interface definition files, plus the scripts used to
     control compilation and installation of the library.

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running a program using the Library is not restricted, and
     output from such a program is covered only if its contents
     constitute a work based on the Library (independent of the use of
     the Library in a tool for writing it).  Whether that is true
     depends on what the Library does and what the program that uses
     the Library does.

  1. You may copy and distribute verbatim copies of the Library's
     complete source code as you receive it, in any medium, provided
     that you conspicuously and appropriately publish on each copy an
     appropriate copyright notice and disclaimer of warranty; keep
     intact all the notices that refer to this License and to the
     absence of any warranty; and distribute a copy of this License
     along with the Library.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Library or any portion
     of it, thus forming a work based on the Library, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. The modified work must itself be a software library.

       b. You must cause the files modified to carry prominent notices
          stating that you changed the files and the date of any change.

       c. You must cause the whole of the work to be licensed at no
          charge to all third parties under the terms of this License.

       d. If a facility in the modified Library refers to a function or
          a table of data to be supplied by an application program that
          uses the facility, other than as an argument passed when the
          facility is invoked, then you must make a good faith effort
          to ensure that, in the event an application does not supply
          such function or table, the facility still operates, and
          performs whatever part of its purpose remains meaningful.

          (For example, a function in a library to compute square roots
          has a purpose that is entirely well-defined independent of the
          application.  Therefore, Subsection 2d requires that any
          application-supplied function or table used by this function
          must be optional: if the application does not supply it, the
          square root function must still compute square roots.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Library, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Library, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Library.

     In addition, mere aggregation of another work not based on the
     Library with the Library (or with a work based on the Library) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
     License instead of this License to a given copy of the Library.
     To do this, you must alter all the notices that refer to this
     License, so that they refer to the ordinary GNU General Public
     License, version 2, instead of to this License.  (If a newer
     version than version 2 of the ordinary GNU General Public License
     has appeared, then you can specify that version instead if you
     wish.)  Do not make any other change in these notices.

     Once this change is made in a given copy, it is irreversible for
     that copy, so the ordinary GNU General Public License applies to
     all subsequent copies and derivative works made from that copy.

     This option is useful when you wish to copy part of the code of
     the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
     derivative of it, under Section 2) in object code or executable
     form under the terms of Sections 1 and 2 above provided that you
     accompany it with the complete corresponding machine-readable
     source code, which must be distributed under the terms of Sections
     1 and 2 above on a medium customarily used for software
     interchange.

     If distribution of object code is made by offering access to copy
     from a designated place, then offering equivalent access to copy
     the source code from the same place satisfies the requirement to
     distribute the source code, even though third parties are not
     compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
     Library, but is designed to work with the Library by being
     compiled or linked with it, is called a "work that uses the
     Library".  Such a work, in isolation, is not a derivative work of
     the Library, and therefore falls outside the scope of this License.

     However, linking a "work that uses the Library" with the Library
     creates an executable that is a derivative of the Library (because
     it contains portions of the Library), rather than a "work that
     uses the library".  The executable is therefore covered by this
     License.  Section 6 states terms for distribution of such
     executables.

     When a "work that uses the Library" uses material from a header
     file that is part of the Library, the object code for the work may
     be a derivative work of the Library even though the source code is
     not.  Whether this is true is especially significant if the work
     can be linked without the Library, or if the work is itself a
     library.  The threshold for this to be true is not precisely
     defined by law.

     If such an object file uses only numerical parameters, data
     structure layouts and accessors, and small macros and small inline
     functions (ten lines or less in length), then the use of the object
     file is unrestricted, regardless of whether it is legally a
     derivative work.  (Executables containing this object code plus
     portions of the Library will still fall under Section 6.)

     Otherwise, if the work is a derivative of the Library, you may
     distribute the object code for the work under the terms of Section
     6.  Any executables containing that work also fall under Section 6,
     whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also compile or
     link a "work that uses the Library" with the Library to produce a
     work containing portions of the Library, and distribute that work
     under terms of your choice, provided that the terms permit
     modification of the work for the customer's own use and reverse
     engineering for debugging such modifications.

     You must give prominent notice with each copy of the work that the
     Library is used in it and that the Library and its use are covered
     by this License.  You must supply a copy of this License.  If the
     work during execution displays copyright notices, you must include
     the copyright notice for the Library among them, as well as a
     reference directing the user to the copy of this License.  Also,
     you must do one of these things:

       a. Accompany the work with the complete corresponding
          machine-readable source code for the Library including
          whatever changes were used in the work (which must be
          distributed under Sections 1 and 2 above); and, if the work
          is an executable linked with the Library, with the complete
          machine-readable "work that uses the Library", as object code
          and/or source code, so that the user can modify the Library
          and then relink to produce a modified executable containing
          the modified Library.  (It is understood that the user who
          changes the contents of definitions files in the Library will
          not necessarily be able to recompile the application to use
          the modified definitions.)

       b. Accompany the work with a written offer, valid for at least
          three years, to give the same user the materials specified in
          Subsection 6a, above, for a charge no more than the cost of
          performing this distribution.

       c. If distribution of the work is made by offering access to copy
          from a designated place, offer equivalent access to copy the
          above specified materials from the same place.

       d. Verify that the user has already received a copy of these
          materials or that you have already sent this user a copy.

     For an executable, the required form of the "work that uses the
     Library" must include any data and utility programs needed for
     reproducing the executable from it.  However, as a special
     exception, the source code distributed need not include anything
     that is normally distributed (in either source or binary form)
     with the major components (compiler, kernel, and so on) of the
     operating system on which the executable runs, unless that
     component itself accompanies the executable.

     It may happen that this requirement contradicts the license
     restrictions of other proprietary libraries that do not normally
     accompany the operating system.  Such a contradiction means you
     cannot use both them and the Library together in an executable
     that you distribute.

  7. You may place library facilities that are a work based on the
     Library side-by-side in a single library together with other
     library facilities not covered by this License, and distribute
     such a combined library, provided that the separate distribution
     of the work based on the Library and of the other library
     facilities is otherwise permitted, and provided that you do these
     two things:

       a. Accompany the combined library with a copy of the same work
          based on the Library, uncombined with any other library
          facilities.  This must be distributed under the terms of the
          Sections above.

       b. Give prominent notice with the combined library of the fact
          that part of it is a work based on the Library, and explaining
          where to find the accompanying uncombined form of the same
          work.

  8. You may not copy, modify, sublicense, link with, or distribute the
     Library except as expressly provided under this License.  Any
     attempt otherwise to copy, modify, sublicense, link with, or
     distribute the Library is void, and will automatically terminate
     your rights under this License.  However, parties who have
     received copies, or rights, from you under this License will not
     have their licenses terminated so long as such parties remain in
     full compliance.

  9. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Library or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Library (or any work
     based on the Library), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Library or works based on it.

 10. Each time you redistribute the Library (or any work based on the
     Library), the recipient automatically receives a license from the
     original licensor to copy, distribute, link with or modify the
     Library subject to these terms and conditions.  You may not impose
     any further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties to this License.

 11. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Library at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Library by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Library.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply, and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

 12. If the distribution and/or use of the Library is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Library under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

 13. The Free Software Foundation may publish revised and/or new
     versions of the Library General Public License from time to time.
     Such new versions will be similar in spirit to the present version,
     but may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Library specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Library
     does not specify a license version number, you may choose any
     version ever published by the Free Software Foundation.

 14. If you wish to incorporate parts of the Library into other free
     programs whose distribution conditions are incompatible with these,
     write to the author to ask for permission.  For software which is
     copyrighted by the Free Software Foundation, write to the Free
     Software Foundation; we sometimes make exceptions for this.  Our
     decision will be guided by the two goals of preserving the free
     status of all derivatives of our free software and of promoting
     the sharing and reuse of software generally.

                                NO WARRANTY

 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH YOU.  SHOULD THE
     LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE LIBRARY TO OPERATE WITH ANY
     OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS

How to Apply These Terms to Your New Libraries
==============================================

If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of
the ordinary General Public License).

To apply these terms, attach the following notices to the library.  It
is safest to attach them to the start of each source file to most
effectively convey the exclusion of warranty; and each file should have
at least the "copyright" line and a pointer to where the full notice is
found.

     ONE LINE TO GIVE THE LIBRARY'S NAME AND AN IDEA OF WHAT IT DOES.
     Copyright (C) YEAR  NAME OF AUTHOR
     
     This library is free software; you can redistribute it and/or
     modify it under the terms of the GNU Library General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later version.
     
     This library is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     Library General Public License for more details.
     
     You should have received a copy of the GNU Library General Public
     License along with this library; if not, write to the
     Free Software Foundation, Inc., 59 Temple Place - Suite 330, Cambridge,
     MA 02139, USA.

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright interest in
     the library `Frob' (a library for tweaking knobs) written
     by James Random Hacker.
     
     SIGNATURE OF TY COON, 1 April 1990
     Ty Coon, President of Vice

That's all there is to it!


File: DLdoc.info,  Node: Introduction,  Next: Dynamics overview,  Prev: Copying,  Up: Top

Introduction
************

This is the user documentation for the Dynamo Library: a C++ class
library developed at the Eindhoven University of Technology for handling
dynamics and inverse dynamics motion behaviour in computer animation and
simulation.

This documentation is structured as follows: first, a very brief
overview is given of what (inverse) dynamics entails. Then the few
things needed to connect the library to a host system are discussed.
This involves implementing a few simple callbacks. Once these callbacks
have been implemented, the library can be used. That is what the
remainder of this documentation focuses on, by first giving some
general hints about the usage of the library, and then presenting the
API of the library. In this API description all relevant classes in the
library are presented along with a description of each of their methods.

More in-depth documentation describing the theory on which the library
is based can be found at the author's home page on the Internet at url
`http://www.win.tue.nl/win/cs/tt/bartb/'. For questions, the author can
be reached at e-mail address `bartb@win.tue.nl'.


File: DLdoc.info,  Node: Dynamics overview,  Next: General notes,  Prev: Introduction,  Up: Top

Dynamics overview
*****************

Dynamics provides a way to specify motion behaviour for an animation or
simulation. Unlike kinematics, where motions are specified in terms of
translations and rotations, dynamics uses forces and torques to set the
animation geometries in motion. The dynamics algorithms use the laws of
physics to calculate the motion of objects. In order to be able to
calculate the dynamic motions, some physical properties of the animated
objects are required, such as the mass of the objects.

Inverse dynamics provides a tool to specify the dynamics forces on a
higher level by stating properties of the dynamics objects. Inverse
dynamics takes care of calculating and applying the (reaction) forces
that maintain those properties. The properties are specified in
so-called "constraints". A constraint might for example specify that two
objects are to remain connected in a given manner at all times (with a
ball joint, or a pin joint for example). The constraint then acts as a
hinge between the two objects by calculating and applying the hinge
force. The advantage of constraints is that they can be used in a
declarative fashion: once a constraint is specified, the inverse
dynamics engine will make sure it remains satisfied for the remainder of
the animation/simulation (or until the constraint is "deactivated").


File: DLdoc.info,  Node: General notes,  Next: Installation,  Prev: Dynamics overview,  Up: Top

General notes
*************

The task of the Dynamo Library is calculate the motions of the
geometric objects that are under its control. These geometric objects
exist outside the Dynamo library, and so the library itself maintains
companion objects that make the information required for the dynamics
calculation available to the objects in the library.

The calculations themselves are controlled by two system components: one
of type `DL_dyna_system' (for the forward dynamics), and one of type
`DL_constraint_manager' (for the inverse dynamics). The dyna system
component provides the entry-point for the dynamics calculation in the
form of the `dynamics()' method: this method is to be called once for
each time step in the animation/simulation and will take care that all
the dynamically controlled objects (`dynas' for short) will also make a
time step according to their inertia, external forces and torques, and
the constraints imposed on them. The method is also available as a
C-function `dynamics()'.

Sometimes constraints are specified between a dyna and a geometric
object that is not under control of the Dynamo library. Companion
objects (`geos') for such objects are also maintained by the library.
The dyna system object provides methods that enable you to register a
geometric object as either a geo or a dyna. When the `dynamics' method
make a time step, it assumes that the geos have already made their
step: that way it can position the dynas in such a way that at the new
time, the constraints are valid again.

The header files for the Dynamo library list more classes, attributes
and methods than described in this document. However, only the methods
documented here are intended to be used externally to the library. Other
methods (which are marked as such) are present in the header
definitions, but are only for use by other classes in the library. The
classes in the Dynamo library have the prefix `DL_' prepended to their
name to distinguish them from other classes.

Points and vectors are often expressed in the local coordinate system of
some geo. So often you see as parameters a pair `DL_point *p, DL_geo
*g', expressing that point `p' is given in the local coordinate system
of geo `g'. In such cases, `g' can be passed the value `NULL' to
indicate that `p' is given in world coordinates.


File: DLdoc.info,  Node: Installation,  Next: Example,  Prev: General notes,  Up: Top

Installation
************

Before the Dynamo library can be used, several things have to be done.

Since the dynamics calculations are carried out by the dyna system and
the constraint manager object (see the General notes section), those two
objects need be created during the initialization (if no inverse
dynamics is used, the creation of the constraint manager object may be
omitted). Moreover, the dyna_system object requires a motion integrator
to be present (see the section on forward dynamics), so a motion
integrator of choice will have to be created and installed as well

For the information exchange between the actual geometric objects and
their companions, a few very simple callbacks have to be implemented.
These callbacks are grouped together in a class-definition
`DL_dyna_system_callbacks'. Its API is given below, and the class is
meant to be used as a superclass for an actual implementation. An
object of this class also needs to be created during the initialization
phase to serve as a companion for the dyna system object.

An object of this class is used as companion to the dyna_system. Since
the dyna_system also needs a reference to a force_drawer, this callbacks
class inherits from the `DL_force_drawer' class so its methods can
(optionally) be implemented too and are easily accessible.

     class DL_dyna_system_callbacks : public DL_force_drawer {
         void update_dyna_companion(DL_dyna*);
         void get_new_geo_info(DL_geo*);
         void get_first_geo_info(DL_geo*);
         void check_inertiatensor(DL_dyna*);
         void do_collision_detection();
         void Msg(char*, ...);
     }

Only the first two methods need to be implemented: the others are
optional since they have a default implementation:

`void DL_dyna_system_callbacks::update_dyna_companion(DL_dyna *d)'
     This method should copy the newly calculated position and
     orientation of a dyna to its geometric companion object after its
     new position is calculated.

`void DL_dyna_system_callbacks::get_new_geo_info(DL_geo *g)'
     This method has the same function as the `update_dyna_companion'
     method, but does its copying in the other direction. It is used to
     copy new information from a non-dynamically controlled geometric
     object to its companion in the Dynamo library.  Its argument
     provides a reference to the `DL_geo' who's position and
     orientation need to be updated. The `DL_geo' class has a method
     `move' especially for this purpose. A reference to the companion
     object of this `DL_geo' can be retrieved using its
     `get_companion()' method. The difference between this callback and
     the `get_first_geo_info' callback is that the latter is used to
     initialise a companion (so it has to set the motion state for time
     `t' as well as for time `t+h'), and this callback is used to
     increment the time by shifting the next motion state into the
     current one, and only specify the new motion motion state.

`void DL_dyna_system_callbacks::get_first_geo_info(DL_geo *g)'
     This method is used to copy the information from a geometric
     object to its companion in the Dynamo library when the companion
     is created.  Its argument provides a reference to the `DL_geo'
     who's positions and orientations need to be set. A reference to
     the companion object of this `DL_geo' can be retrieved using its
     `get_companion()' method. The default implementation of this
     method calls the `get_new_geo_info' method to obtain the position
     and orientation of the geometry, and copies this into both the new
     and current motion states, while setting the velocities to zero.
     For non-zero initial velocities, this method should be overriden.

`void DL_dyna_system_callbacks::check_inertiatensor(DL_dyna*)'
     The dynamic calculations for each dyna depend on some of the
     physical properties of the dyna, such as its mass and its tensor of
     inertia. This callback gives the geometric companion object of a
     dyna a chance to update these properties if necessary (for example
     when the geometric companion object has been deformed).

`void DL_dyna_system_callbacks::do_collision_detection()'
     The Dynamo library has a `collision' constraint for collision
     handling. But it relies on external collision detection to
     determine when such a constraint should be created. This callback
     is used to call the collision detector at the right moment. This
     callback should implement a call to the collision detector to do
     its work (possibly preceded by updating the positions of the
     geometries in the collision detector's datastructures), which in
     turn should create collision constraints upon detection of a
     collision.

     The collision detection should use the estimates for the next
     motion state to determine if a collision is taking place. To this
     end, the geometry class has a set of methods (not listed in its
     interface description below, since they normally are only used by
     the other components of Dynamo, and only have valid values during
     the dynamics phase) for retrieving the geometry's properties based
     on the estimate for next frame's motion state. See the `geo.h'
     file for their interfaces.

     When overlap is detected by a collision detector, it is usually a
     good idea to only create a collision constraint for the case where
     the colliding geometries are moving closer to each other: if they
     are already moving away from each other (maybe because of a
     collision constraint in the previous frame), the "mirror the
     velocity" approach of Dynamo's collision constraint only has
     adverse effects.

`void DL_dyna_system_callbacks::Msg(char *fmt, ...)'
     This method is used by Dynamo to send messages (warnings, errors,
     notificications) to the outside world. The default implementation
     prints the message on stderr, but for windowing systems it is often
     better to reroute these messages to some window.


File: DLdoc.info,  Node: Example,  Next: General classes,  Prev: Installation,  Up: Top

Example
*******

The following code shows the use of the Dynamo library classes in
creating a chain of cubes swinging due to gravity. The render
functionality is provided in the `render.cpp' file

     // A demo for the use of the Dynamo classes.
     // It shows a chain of cubes that swings under influence of gravity.
     
     #include "rungekutta2.h"
     #include "ptp.h"
     
     // How many cubes make up the chain?:
     #define NCUBES 15
     
     // Here is the class for our cubes, these function mainly as an intermediate
     // between the dyna companion, the control routine, and the rendering software.
     class MyCube {
       public:
         // the attributes of the cube:
         DL_point pos;       // the position of the center of the cube
         DL_matrix orient;   // the orientation of the cube
         DL_dyna* companion; // the companion which does all the dynamics
                             // calculations for us
         DL_ptp* link;       // used to connect this cube to another
     
         // the functions needed for the DL_dyna_callback to copy position and
         // orientation to/from the companion:
         void get_new_geo_info(DL_geo *g){
           g->move(&pos,&orient);
         }
         void update_dyna_companion(DL_dyna *d){
           pos.assign(d->get_position());
           orient.assign(d->get_orientation());
         }
     
         // show an example of a constraint: this method uses a point-to-point
         // constraint to connect one of the cube's corners to a corner of the
         // other cube.
         void ConnectTo(MyCube *cube){
           DL_point posm(1,1,1),posp(-1,-1,-1);
           link=new DL_ptp();
           if (cube) link->init(companion,&posm,cube->companion,&posp);
           else { // connect to the current position of the corner in the world.
             DL_point posw;
             companion->to_world(&posm,&posw);
             link->init(companion,&posm,NULL,&posw);
           }
         }
         void Disconnect(){
           if (link) delete link;
           link=NULL;
         }
     
         MyCube(DL_point& newpos){
         // constructor: its main task is creating and initialising the companion
           pos.assign(&newpos);
           orient.makeone();
           companion=new DL_dyna((void*)this);
           companion->set_mass(1);
           companion->set_inertiatensor(1,1,1);
           companion->set_velodamping(0.995); // introduce a bit of friction
           link=NULL;
         }
         ~MyCube(){
           if (link) delete link;
           delete companion;
         }
     };
     
     // we need to implement the callbacks that allow the dyna system to commicate
     // its calculated positions and orientations to us:
     class My_dyna_system_callbacks : public DL_dyna_system_callbacks {
       public:
         virtual void get_new_geo_info(DL_geo *g){
           ((MyCube*)(g->get_companion()))->get_new_geo_info(g);
         }
         virtual void update_dyna_companion(DL_dyna *d){
           ((MyCube*)(d->get_companion()))->update_dyna_companion(d);
         }
     };
     
     // rendering is taken care of elsewhere:
     #include "render.cpp"
     
     // here comes the main control function: it initialises the dyna system
     // and then creates a chain of cubes
     void main(){
       int i;
       MyCube* cube[NCUBES];
       My_dyna_system_callbacks *dsc=new My_dyna_system_callbacks();
       DL_m_integrator* my_int=new DL_rungekutta2();
       DL_dyna_system dsystem(dsc,my_int);
       DL_constraint_manager *constraints=new DL_constraint_manager();
       constraints->max_error=0.0001;
     
       DL_point pos(0.75*NCUBES,1.75*NCUBES,4*NCUBES);
       DL_vector vec(-2,-2,-2);
     
       for (i=0;i<NCUBES;i++){
         cube[i]=new MyCube(pos);
         pos.plusis(&vec);
       }
     
       cube[0]->ConnectTo(NULL);
       for (i=1;i<NCUBES;i++) cube[i]->ConnectTo(cube[i-1]);
     
       vec.init(0,-1,0);
       dsystem.set_gravity(&vec);
       my_int->set_stepsize(0.02);
     
       InitRender(dsystem,cube,NCUBES);
     
       // everything initialised. Now let the animation run:
       while (RenderCubes(cube)) {
         dsystem.dynamics();
         if (fabs(dsystem.time()-70)<0.01) cube[NCUBES/2]->Disconnect();
       }
     
       // all done: clean up:
       for (i=0;i<NCUBES;i++) delete cube[i];
       delete constraints; delete my_int; delete dsc;
     }


File: DLdoc.info,  Node: General classes,  Next: Forward dynamics classes,  Prev: Example,  Up: Top

General classes
***************

Before presenting the classes that are used for the dynamics, several
standard classes for manipulating with points, vectors, matrices and
lists have to be presented: objects of these classes are often used as
parameters in the other classes. Many objects use the type `DL_Scalar'
which resolves to `double' (but which can easily be changed if
required).

* Menu:

* points::   The point class
* vectors::  The vector class
* matrices:: The matrix class
* lists::    The list class and the list element class


File: DLdoc.info,  Node: points,  Next: vectors,  Up: General classes

Points
======

Here is the API for the 3-D point class:

     class DL_point : public DL_ListElem {
         DL_Scalar  x,y,z;
     
         void       init(DL_Scalar,DL_Scalar,DL_Scalar);
         void       assign(DL_point*);
         boolean    equal(DL_point*);
     
         void       plus(DL_vector*,DL_point*);
         void       minus(DL_point*,DL_vector*);
         void       times(DL_Scalar,DL_point*);
     
         void       plusis(DL_vector*);
         void       minusis(DL_vector*);
         void       timesis(DL_Scalar);
     
         void       tovector(DL_vector*);
     
                    DL_point();
                    DL_point(DL_point*);
                    DL_point(DL_Scalar,DL_Scalar,DL_Scalar);
                    ~DL_point();
     }

`DL_Scalar DL_point::x'
`DL_Scalar DL_point::y'
`DL_Scalar DL_point::z'
     These attributes hold the position of the point.

`void DL_point::init(DL_Scalar nx, DL_Scalar ny, DL_Scalar nz)'
     This method assigns coordinates (`nx,ny,nz') to the point

`void DL_point::assign(DL_point *p)'
     This method assigns the coordinates of point `p' to this point.

`boolean DL_point::equal(DL_point *p)'
     This method returns if point `p' and this point have the same
     coordinates.

`void DL_point::plus(DL_vector *v, DL_point *sum)'
     This method assigns to point `sum' the sum of this point and vector
     `v'.

`void DL_point::minus(DL_point *p, DL_vector *diff)'
     This method assigns to vector `diff' the difference between this
     point and point `p'.

`void DL_point::times(DL_Scalar f, DL_point *p)'
     This method assigns to point `p' the product of this point and `f'.

`void DL_point::plusis(DL_vector *v)'
     This method adds vector `v' to this point.

`void DL_point::minusis(DL_point *p)'
     This method substracts vector `diff' from this point.

`void DL_point::timesis(DL_Scalar f)'
     This method multiplies this point by a factor `f'.

`void DL_point::tovector(DL_vector *v)'
     This method assigns the coordinates of this point to vector `v'.


File: DLdoc.info,  Node: vectors,  Next: matrices,  Prev: points,  Up: General classes

Vectors
=======

Here is the API for the 3-D vector class:

     class DL_vector {
         DL_Scalar x,y,z;
     
         void      init(DL_Scalar,DL_Scalar,DL_Scalar);
         void      assign(DL_vector*);
         DL_Scalar norm();
         void      normalize();
         DL_Scalar inprod(DL_vector*);
         void      plusis(DL_vector*);
         void      minusis(DL_vector*);
         void      timesis(DL_Scalar);
         boolean   equal(DL_vector*);
     
         DL_Scalar get(int);
         void      set(int,DL_Scalar);
     
         void      crossprod(DL_vector*,DL_vector*);
         void      neg(DL_vector*);
         void      times(DL_Scalar,DL_vector*);
         void      plus(DL_vector*,DL_vector*);
         void      minus(DL_vector*,DL_vector*);
         void      topoint(DL_point*);
     
                 DL_vector();
                 DL_vector(DL_vector*);
                 DL_vector(DL_Scalar,DL_Scalar,DL_Scalar);
                 ~DL_vector();
     }

`DL_Scalar DL_vector::x'
`DL_Scalar DL_vector::y'
`DL_Scalar DL_vector::z'
     These attributes hold the coordinates of the vector

`void DL_vector::init(DL_Scalar nx, DL_Scalar ny, DL_Scalar nz)'
     This method assigns coordinates (`nx,ny,nz') to the vector

`void DL_vector::assign(DL_vector *v)'
     This method assigns the coordinates of vector `v' to this vector.

`DL_Scalar DL_vector::norm()'
     This method returns the length of the vector

`void DL_vector::normalize()'
     This vector normalizes the length of the vector to one.

`DL_Scalar DL_vector::inprod(DL_vector *v)'
     This method returns the inner product of this vector and vector
     `v'.

`void DL_vector::plusis(DL_vector *v)'
     This method adds vector `v' to this vector.

`void DL_vector::minusis(DL_vector *v)'
     This method subtracts vector `v' from this vector.

`void DL_vector::timesis(DL_Scalar f)'
     This method multiplies this vector by factor `f'.

`boolean DL_vector::equal(DL_vector *v)'
     This method returns if this vector has the same coordinates as
     vector `v'.

`DL_Scalar DL_vector::get(int i)'
     This method returns `x' if `i' is zero, `y' if `i' is one, and `z'
     if `i' is two.

`void DL_vector::set(int i, DL_Scalar f)'
     This method assigns `f' to the `i'-th coordinate of this vector
     (i=0,1,2).

`void DL_vector::crossprod(DL_vector *v, DL_vector *c)'
     This method assigns the cross product of vector `v' and this
     vector to vector `c'.

`void DL_vector::neg(DL_vector *v)'
     This method assigns the negation of this vector to vector `v'.

`void DL_vector::times(DL_Scalar f, DL_vector *v)'
     This method assigns the product of this vector and `f' to `v'

`void DL_vector::plus(DL_vector *v, DL_vector *sum)'
     This method assigns the sum of this vector and `v' to `sum'.

`void DL_vector::minus(DL_vector *v, DL_vector *diff)'
     This method assigns the difference between this vector and `v' to
     `diff'.

`void DL_vector::topoint(DL_point *p)'
     This method assigns the coordinates of this vector to point `p'.

